// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ukex.order.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ukex_2eorder_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ukex_2eorder_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ukex_2eorder_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ukex_2eorder_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ukex_2eorder_2eproto;
namespace ukex {
class order;
class orderDefaultTypeInternal;
extern orderDefaultTypeInternal _order_default_instance_;
class order_Data;
class order_DataDefaultTypeInternal;
extern order_DataDefaultTypeInternal _order_Data_default_instance_;
}  // namespace ukex
PROTOBUF_NAMESPACE_OPEN
template<> ::ukex::order* Arena::CreateMaybeMessage<::ukex::order>(Arena*);
template<> ::ukex::order_Data* Arena::CreateMaybeMessage<::ukex::order_Data>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ukex {

enum order_CONST : int {
  order_CONST_CMD = 115
};
bool order_CONST_IsValid(int value);
constexpr order_CONST order_CONST_CONST_MIN = order_CONST_CMD;
constexpr order_CONST order_CONST_CONST_MAX = order_CONST_CMD;
constexpr int order_CONST_CONST_ARRAYSIZE = order_CONST_CONST_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* order_CONST_descriptor();
template<typename T>
inline const std::string& order_CONST_Name(T enum_t_value) {
  static_assert(::std::is_same<T, order_CONST>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function order_CONST_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    order_CONST_descriptor(), enum_t_value);
}
inline bool order_CONST_Parse(
    const std::string& name, order_CONST* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<order_CONST>(
    order_CONST_descriptor(), name, value);
}
// ===================================================================

class order_Data :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ukex.order.Data) */ {
 public:
  order_Data();
  virtual ~order_Data();

  order_Data(const order_Data& from);
  order_Data(order_Data&& from) noexcept
    : order_Data() {
    *this = ::std::move(from);
  }

  inline order_Data& operator=(const order_Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline order_Data& operator=(order_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const order_Data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const order_Data* internal_default_instance() {
    return reinterpret_cast<const order_Data*>(
               &_order_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(order_Data& a, order_Data& b) {
    a.Swap(&b);
  }
  inline void Swap(order_Data* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline order_Data* New() const final {
    return CreateMaybeMessage<order_Data>(nullptr);
  }

  order_Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<order_Data>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const order_Data& from);
  void MergeFrom(const order_Data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(order_Data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukex.order.Data";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ukex_2eorder_2eproto);
    return ::descriptor_table_ukex_2eorder_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kAmountFieldNumber = 3,
    kTotalFieldNumber = 4,
    kInitialRateFieldNumber = 5,
    kInitialAmountFieldNumber = 6,
    kFilledAmountFieldNumber = 7,
    kCurrencyPairFieldNumber = 8,
    kStatusFieldNumber = 10,
    kOrderNumberFieldNumber = 1,
    kTimestampFieldNumber = 9,
  };
  // required string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required string amount = 3;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const std::string& amount() const;
  void set_amount(const std::string& value);
  void set_amount(std::string&& value);
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  std::string* mutable_amount();
  std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // required string total = 4;
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  const std::string& total() const;
  void set_total(const std::string& value);
  void set_total(std::string&& value);
  void set_total(const char* value);
  void set_total(const char* value, size_t size);
  std::string* mutable_total();
  std::string* release_total();
  void set_allocated_total(std::string* total);
  private:
  const std::string& _internal_total() const;
  void _internal_set_total(const std::string& value);
  std::string* _internal_mutable_total();
  public:

  // required string initialRate = 5;
  bool has_initialrate() const;
  private:
  bool _internal_has_initialrate() const;
  public:
  void clear_initialrate();
  const std::string& initialrate() const;
  void set_initialrate(const std::string& value);
  void set_initialrate(std::string&& value);
  void set_initialrate(const char* value);
  void set_initialrate(const char* value, size_t size);
  std::string* mutable_initialrate();
  std::string* release_initialrate();
  void set_allocated_initialrate(std::string* initialrate);
  private:
  const std::string& _internal_initialrate() const;
  void _internal_set_initialrate(const std::string& value);
  std::string* _internal_mutable_initialrate();
  public:

  // required string initialAmount = 6;
  bool has_initialamount() const;
  private:
  bool _internal_has_initialamount() const;
  public:
  void clear_initialamount();
  const std::string& initialamount() const;
  void set_initialamount(const std::string& value);
  void set_initialamount(std::string&& value);
  void set_initialamount(const char* value);
  void set_initialamount(const char* value, size_t size);
  std::string* mutable_initialamount();
  std::string* release_initialamount();
  void set_allocated_initialamount(std::string* initialamount);
  private:
  const std::string& _internal_initialamount() const;
  void _internal_set_initialamount(const std::string& value);
  std::string* _internal_mutable_initialamount();
  public:

  // required string filledAmount = 7;
  bool has_filledamount() const;
  private:
  bool _internal_has_filledamount() const;
  public:
  void clear_filledamount();
  const std::string& filledamount() const;
  void set_filledamount(const std::string& value);
  void set_filledamount(std::string&& value);
  void set_filledamount(const char* value);
  void set_filledamount(const char* value, size_t size);
  std::string* mutable_filledamount();
  std::string* release_filledamount();
  void set_allocated_filledamount(std::string* filledamount);
  private:
  const std::string& _internal_filledamount() const;
  void _internal_set_filledamount(const std::string& value);
  std::string* _internal_mutable_filledamount();
  public:

  // required string currencyPair = 8;
  bool has_currencypair() const;
  private:
  bool _internal_has_currencypair() const;
  public:
  void clear_currencypair();
  const std::string& currencypair() const;
  void set_currencypair(const std::string& value);
  void set_currencypair(std::string&& value);
  void set_currencypair(const char* value);
  void set_currencypair(const char* value, size_t size);
  std::string* mutable_currencypair();
  std::string* release_currencypair();
  void set_allocated_currencypair(std::string* currencypair);
  private:
  const std::string& _internal_currencypair() const;
  void _internal_set_currencypair(const std::string& value);
  std::string* _internal_mutable_currencypair();
  public:

  // required string status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // required uint64 orderNumber = 1;
  bool has_ordernumber() const;
  private:
  bool _internal_has_ordernumber() const;
  public:
  void clear_ordernumber();
  ::PROTOBUF_NAMESPACE_ID::uint64 ordernumber() const;
  void set_ordernumber(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ordernumber() const;
  void _internal_set_ordernumber(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 timestamp = 9;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:ukex.order.Data)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initialrate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initialamount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filledamount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencypair_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ordernumber_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  friend struct ::TableStruct_ukex_2eorder_2eproto;
};
// -------------------------------------------------------------------

class order :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ukex.order) */ {
 public:
  order();
  virtual ~order();

  order(const order& from);
  order(order&& from) noexcept
    : order() {
    *this = ::std::move(from);
  }

  inline order& operator=(const order& from) {
    CopyFrom(from);
    return *this;
  }
  inline order& operator=(order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const order* internal_default_instance() {
    return reinterpret_cast<const order*>(
               &_order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(order& a, order& b) {
    a.Swap(&b);
  }
  inline void Swap(order* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline order* New() const final {
    return CreateMaybeMessage<order>(nullptr);
  }

  order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<order>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const order& from);
  void MergeFrom(const order& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(order* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukex.order";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ukex_2eorder_2eproto);
    return ::descriptor_table_ukex_2eorder_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef order_Data Data;

  typedef order_CONST CONST;
  static constexpr CONST CMD =
    order_CONST_CMD;
  static inline bool CONST_IsValid(int value) {
    return order_CONST_IsValid(value);
  }
  static constexpr CONST CONST_MIN =
    order_CONST_CONST_MIN;
  static constexpr CONST CONST_MAX =
    order_CONST_CONST_MAX;
  static constexpr int CONST_ARRAYSIZE =
    order_CONST_CONST_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CONST_descriptor() {
    return order_CONST_descriptor();
  }
  template<typename T>
  static inline const std::string& CONST_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CONST>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CONST_Name.");
    return order_CONST_Name(enum_t_value);
  }
  static inline bool CONST_Parse(const std::string& name,
      CONST* value) {
    return order_CONST_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // required string orders = 1;
  bool has_orders() const;
  private:
  bool _internal_has_orders() const;
  public:
  void clear_orders();
  const std::string& orders() const;
  void set_orders(const std::string& value);
  void set_orders(std::string&& value);
  void set_orders(const char* value);
  void set_orders(const char* value, size_t size);
  std::string* mutable_orders();
  std::string* release_orders();
  void set_allocated_orders(std::string* orders);
  private:
  const std::string& _internal_orders() const;
  void _internal_set_orders(const std::string& value);
  std::string* _internal_mutable_orders();
  public:

  // required .ukex.order.Data data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::ukex::order_Data& data() const;
  ::ukex::order_Data* release_data();
  ::ukex::order_Data* mutable_data();
  void set_allocated_data(::ukex::order_Data* data);
  private:
  const ::ukex::order_Data& _internal_data() const;
  ::ukex::order_Data* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:ukex.order)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orders_;
  ::ukex::order_Data* data_;
  friend struct ::TableStruct_ukex_2eorder_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// order_Data

// required uint64 orderNumber = 1;
inline bool order_Data::_internal_has_ordernumber() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool order_Data::has_ordernumber() const {
  return _internal_has_ordernumber();
}
inline void order_Data::clear_ordernumber() {
  ordernumber_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 order_Data::_internal_ordernumber() const {
  return ordernumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 order_Data::ordernumber() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.orderNumber)
  return _internal_ordernumber();
}
inline void order_Data::_internal_set_ordernumber(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  ordernumber_ = value;
}
inline void order_Data::set_ordernumber(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ordernumber(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.orderNumber)
}

// required string type = 2;
inline bool order_Data::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool order_Data::has_type() const {
  return _internal_has_type();
}
inline void order_Data::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& order_Data::type() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.type)
  return _internal_type();
}
inline void order_Data::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.type)
}
inline std::string* order_Data::mutable_type() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.type)
  return _internal_mutable_type();
}
inline const std::string& order_Data::_internal_type() const {
  return type_.GetNoArena();
}
inline void order_Data::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.type)
}
inline void order_Data::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.type)
}
inline void order_Data::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.type)
}
inline std::string* order_Data::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_type() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.type)
  if (!has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.type)
}

// required string amount = 3;
inline bool order_Data::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool order_Data::has_amount() const {
  return _internal_has_amount();
}
inline void order_Data::clear_amount() {
  amount_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& order_Data::amount() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.amount)
  return _internal_amount();
}
inline void order_Data::set_amount(const std::string& value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.amount)
}
inline std::string* order_Data::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.amount)
  return _internal_mutable_amount();
}
inline const std::string& order_Data::_internal_amount() const {
  return amount_.GetNoArena();
}
inline void order_Data::_internal_set_amount(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  amount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_amount(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  amount_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.amount)
}
inline void order_Data::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  amount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.amount)
}
inline void order_Data::set_amount(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  amount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.amount)
}
inline std::string* order_Data::_internal_mutable_amount() {
  _has_bits_[0] |= 0x00000002u;
  return amount_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_amount() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.amount)
  if (!has_amount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return amount_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  amount_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.amount)
}

// required string total = 4;
inline bool order_Data::_internal_has_total() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool order_Data::has_total() const {
  return _internal_has_total();
}
inline void order_Data::clear_total() {
  total_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& order_Data::total() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.total)
  return _internal_total();
}
inline void order_Data::set_total(const std::string& value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.total)
}
inline std::string* order_Data::mutable_total() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.total)
  return _internal_mutable_total();
}
inline const std::string& order_Data::_internal_total() const {
  return total_.GetNoArena();
}
inline void order_Data::_internal_set_total(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  total_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_total(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  total_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.total)
}
inline void order_Data::set_total(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  total_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.total)
}
inline void order_Data::set_total(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  total_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.total)
}
inline std::string* order_Data::_internal_mutable_total() {
  _has_bits_[0] |= 0x00000004u;
  return total_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_total() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.total)
  if (!has_total()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return total_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_total(std::string* total) {
  if (total != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  total_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), total);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.total)
}

// required string initialRate = 5;
inline bool order_Data::_internal_has_initialrate() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool order_Data::has_initialrate() const {
  return _internal_has_initialrate();
}
inline void order_Data::clear_initialrate() {
  initialrate_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& order_Data::initialrate() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.initialRate)
  return _internal_initialrate();
}
inline void order_Data::set_initialrate(const std::string& value) {
  _internal_set_initialrate(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.initialRate)
}
inline std::string* order_Data::mutable_initialrate() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.initialRate)
  return _internal_mutable_initialrate();
}
inline const std::string& order_Data::_internal_initialrate() const {
  return initialrate_.GetNoArena();
}
inline void order_Data::_internal_set_initialrate(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  initialrate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_initialrate(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  initialrate_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.initialRate)
}
inline void order_Data::set_initialrate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  initialrate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.initialRate)
}
inline void order_Data::set_initialrate(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  initialrate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.initialRate)
}
inline std::string* order_Data::_internal_mutable_initialrate() {
  _has_bits_[0] |= 0x00000008u;
  return initialrate_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_initialrate() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.initialRate)
  if (!has_initialrate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return initialrate_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_initialrate(std::string* initialrate) {
  if (initialrate != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  initialrate_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initialrate);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.initialRate)
}

// required string initialAmount = 6;
inline bool order_Data::_internal_has_initialamount() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool order_Data::has_initialamount() const {
  return _internal_has_initialamount();
}
inline void order_Data::clear_initialamount() {
  initialamount_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& order_Data::initialamount() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.initialAmount)
  return _internal_initialamount();
}
inline void order_Data::set_initialamount(const std::string& value) {
  _internal_set_initialamount(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.initialAmount)
}
inline std::string* order_Data::mutable_initialamount() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.initialAmount)
  return _internal_mutable_initialamount();
}
inline const std::string& order_Data::_internal_initialamount() const {
  return initialamount_.GetNoArena();
}
inline void order_Data::_internal_set_initialamount(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  initialamount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_initialamount(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  initialamount_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.initialAmount)
}
inline void order_Data::set_initialamount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  initialamount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.initialAmount)
}
inline void order_Data::set_initialamount(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  initialamount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.initialAmount)
}
inline std::string* order_Data::_internal_mutable_initialamount() {
  _has_bits_[0] |= 0x00000010u;
  return initialamount_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_initialamount() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.initialAmount)
  if (!has_initialamount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return initialamount_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_initialamount(std::string* initialamount) {
  if (initialamount != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  initialamount_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initialamount);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.initialAmount)
}

// required string filledAmount = 7;
inline bool order_Data::_internal_has_filledamount() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool order_Data::has_filledamount() const {
  return _internal_has_filledamount();
}
inline void order_Data::clear_filledamount() {
  filledamount_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& order_Data::filledamount() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.filledAmount)
  return _internal_filledamount();
}
inline void order_Data::set_filledamount(const std::string& value) {
  _internal_set_filledamount(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.filledAmount)
}
inline std::string* order_Data::mutable_filledamount() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.filledAmount)
  return _internal_mutable_filledamount();
}
inline const std::string& order_Data::_internal_filledamount() const {
  return filledamount_.GetNoArena();
}
inline void order_Data::_internal_set_filledamount(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  filledamount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_filledamount(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  filledamount_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.filledAmount)
}
inline void order_Data::set_filledamount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  filledamount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.filledAmount)
}
inline void order_Data::set_filledamount(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  filledamount_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.filledAmount)
}
inline std::string* order_Data::_internal_mutable_filledamount() {
  _has_bits_[0] |= 0x00000020u;
  return filledamount_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_filledamount() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.filledAmount)
  if (!has_filledamount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return filledamount_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_filledamount(std::string* filledamount) {
  if (filledamount != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  filledamount_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filledamount);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.filledAmount)
}

// required string currencyPair = 8;
inline bool order_Data::_internal_has_currencypair() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool order_Data::has_currencypair() const {
  return _internal_has_currencypair();
}
inline void order_Data::clear_currencypair() {
  currencypair_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& order_Data::currencypair() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.currencyPair)
  return _internal_currencypair();
}
inline void order_Data::set_currencypair(const std::string& value) {
  _internal_set_currencypair(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.currencyPair)
}
inline std::string* order_Data::mutable_currencypair() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.currencyPair)
  return _internal_mutable_currencypair();
}
inline const std::string& order_Data::_internal_currencypair() const {
  return currencypair_.GetNoArena();
}
inline void order_Data::_internal_set_currencypair(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  currencypair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_currencypair(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  currencypair_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.currencyPair)
}
inline void order_Data::set_currencypair(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  currencypair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.currencyPair)
}
inline void order_Data::set_currencypair(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  currencypair_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.currencyPair)
}
inline std::string* order_Data::_internal_mutable_currencypair() {
  _has_bits_[0] |= 0x00000040u;
  return currencypair_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_currencypair() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.currencyPair)
  if (!has_currencypair()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return currencypair_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_currencypair(std::string* currencypair) {
  if (currencypair != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  currencypair_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currencypair);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.currencyPair)
}

// required uint64 timestamp = 9;
inline bool order_Data::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool order_Data::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void order_Data::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 order_Data::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 order_Data::timestamp() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.timestamp)
  return _internal_timestamp();
}
inline void order_Data::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  timestamp_ = value;
}
inline void order_Data::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.timestamp)
}

// required string status = 10;
inline bool order_Data::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool order_Data::has_status() const {
  return _internal_has_status();
}
inline void order_Data::clear_status() {
  status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& order_Data::status() const {
  // @@protoc_insertion_point(field_get:ukex.order.Data.status)
  return _internal_status();
}
inline void order_Data::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ukex.order.Data.status)
}
inline std::string* order_Data::mutable_status() {
  // @@protoc_insertion_point(field_mutable:ukex.order.Data.status)
  return _internal_mutable_status();
}
inline const std::string& order_Data::_internal_status() const {
  return status_.GetNoArena();
}
inline void order_Data::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order_Data::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  status_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.Data.status)
}
inline void order_Data::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.Data.status)
}
inline void order_Data::set_status(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.Data.status)
}
inline std::string* order_Data::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000080u;
  return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order_Data::release_status() {
  // @@protoc_insertion_point(field_release:ukex.order.Data.status)
  if (!has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order_Data::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.Data.status)
}

// -------------------------------------------------------------------

// order

// required string orders = 1;
inline bool order::_internal_has_orders() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool order::has_orders() const {
  return _internal_has_orders();
}
inline void order::clear_orders() {
  orders_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& order::orders() const {
  // @@protoc_insertion_point(field_get:ukex.order.orders)
  return _internal_orders();
}
inline void order::set_orders(const std::string& value) {
  _internal_set_orders(value);
  // @@protoc_insertion_point(field_set:ukex.order.orders)
}
inline std::string* order::mutable_orders() {
  // @@protoc_insertion_point(field_mutable:ukex.order.orders)
  return _internal_mutable_orders();
}
inline const std::string& order::_internal_orders() const {
  return orders_.GetNoArena();
}
inline void order::_internal_set_orders(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  orders_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void order::set_orders(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  orders_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ukex.order.orders)
}
inline void order::set_orders(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  orders_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ukex.order.orders)
}
inline void order::set_orders(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  orders_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ukex.order.orders)
}
inline std::string* order::_internal_mutable_orders() {
  _has_bits_[0] |= 0x00000001u;
  return orders_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* order::release_orders() {
  // @@protoc_insertion_point(field_release:ukex.order.orders)
  if (!has_orders()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return orders_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void order::set_allocated_orders(std::string* orders) {
  if (orders != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  orders_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orders);
  // @@protoc_insertion_point(field_set_allocated:ukex.order.orders)
}

// required .ukex.order.Data data = 2;
inline bool order::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool order::has_data() const {
  return _internal_has_data();
}
inline void order::clear_data() {
  if (data_ != nullptr) data_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ukex::order_Data& order::_internal_data() const {
  const ::ukex::order_Data* p = data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ukex::order_Data*>(
      &::ukex::_order_Data_default_instance_);
}
inline const ::ukex::order_Data& order::data() const {
  // @@protoc_insertion_point(field_get:ukex.order.data)
  return _internal_data();
}
inline ::ukex::order_Data* order::release_data() {
  // @@protoc_insertion_point(field_release:ukex.order.data)
  _has_bits_[0] &= ~0x00000002u;
  ::ukex::order_Data* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::ukex::order_Data* order::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::ukex::order_Data>(GetArenaNoVirtual());
    data_ = p;
  }
  return data_;
}
inline ::ukex::order_Data* order::mutable_data() {
  // @@protoc_insertion_point(field_mutable:ukex.order.data)
  return _internal_mutable_data();
}
inline void order::set_allocated_data(::ukex::order_Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:ukex.order.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ukex

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ukex::order_CONST> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ukex::order_CONST>() {
  return ::ukex::order_CONST_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ukex_2eorder_2eproto
